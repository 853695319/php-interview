#### 缓存
CDN缓存、反向代理缓存、本地应用缓存、分布式缓存

CDN(Content Delivery Network 内容分发网络)的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求

反向代理位于应用服务器机房，处理所有对WEB服务器的请求。
如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向WEB服务器的请求数，从而降低了WEB服务器的负载。

本地应用缓存指的是在应用中的缓存组件，其最大的优点是应用和cache是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；
同时，它的缺点也是应为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。

分布式缓存指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存（如redis、memcached）



#### Redis与Memcached比较

|                |                            Redis                             |                          Memcached                           |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 支持的数据结构 |                  哈希、列表、集合、有序集合                  |                         纯kev-value                          |
|   持久化支持   |                              有                              |                              无                              |
|   高可用支持   | redis天然支持集群功能，可以实现主动复制，读写分离。官方也提供了sentinel集群管理工具，能够实现主从服务监控，故障自动转移，这一切，对于客户端都是透明的，无需程序改动，也无需人工介入 |                         需要二次开发                         |
| 存储value容量  |                           最大512M                           |                            最大1M                            |
|    内存分配    |                  临时申请空间，可能导致碎片                  |       预分配内存池的方式管理内存，能够省去内存分配时间       |
|  虚拟内存使用  | 有自己的VM机制，理论上能够存储比物理内存更多的数据，当数据超量时，会引发swap，把冷数据刷到磁盘上 |                  所有的数据存储在物理内存里                  |
|    网络模型    | 非阻塞IO复用模型,提供一些非KV存储之外的排序，聚合功能，在执行这些功能时，复杂的CPU计算，会阻塞整个IO调度 |                       非阻塞IO复用模型                       |
| 水平扩展的支持 |                             暂无                             |                             暂无                             |
|     多线程     |                       Redis支持单线程                        |       Memcached支持多线程,CPU利用方面Memcache优于Redis       |
|    过期策略    |                   有专门线程，清除缓存数据                   | 懒淘汰机制：每次往缓存放入数据的时候，都会存一个时间，在读取的时候要和设置的时间做TTL比较来判断是否过期 |
|    单机QPS     |                            约10W                             |                            约60W                             |
|  源代码可读性  |                         代码清爽简洁                         |      能是考虑了太多的扩展性，多系统的兼容性，代码不清爽      |
|    适用场景    |    复杂数据结构、有持久化、高可用需求、value存储内容较大     |            纯KV，数据量非常大，并发量非常大的业务            |

#### 分层缓存架构设计

 ![分层缓存架构](https://user-gold-cdn.xitu.io/2018/7/9/1647c7f9ec13f9c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

 #### 缓存带来的复杂度问题

- 数据一致性

- 缓存穿透
	 解决方案：对结果为空的数据也进行缓存，当此key有数据后，清理缓存；一定不存在的key，采用布隆过滤器，建立一个大的Bitmap中，查询时通过该bitmap过滤

- 缓存雪崩

- 缓存高可用
	分布式：实现数据的海量缓存
	复制：实现缓存数据节点的高可用

- 缓存热点
	复制多份缓存副本，把请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力

