#### 缓存
CDN缓存、反向代理缓存、本地应用缓存、分布式缓存

CDN(Content Delivery Network 内容分发网络)的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求

反向代理位于应用服务器机房，处理所有对WEB服务器的请求。
如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向WEB服务器的请求数，从而降低了WEB服务器的负载。

本地应用缓存指的是在应用中的缓存组件，其最大的优点是应用和cache是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；
同时，它的缺点也是应为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。

分布式缓存指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存（如redis、memcached）

#### Nginx本地缓存

​Nginx 作为Web服务器或者负载均衡器，一般不执行业务逻辑，而是将请求转到后端服务器，比如 Tomcat 或者 php-fpm，后端处理完毕之后将经过 nginx 将数据返回给用户。
在请求转发的过程中，nginx 可将中间数据在本地进行缓存，这样未来一段时间内的请求相同的数据，Nginx 可以直接返回本地复本，而不是再次向后端服务发起请求，可以大大降低后端服务器的压力。
同时，在后端服务器宕机时，Nginx 还可返回缓存数据，而不中端服务，提高了服务的可用性。

```
# 定义缓存路径、过期时间、空间大小等
proxy_cache_path  /tmp/nginx/cache levels=2:2:2 use_temp_path=off keys_zone=my_cache_name:10m inactive=1h max_size=1g;

server {
    listen       8000;
    server_name  localhost;
    # 添加缓存的 http 状态头
    add_header X-Cache-Status $upstream_cache_status;

    location / {
            # 定义缓存名称
            proxy_cache my_cache_name;
            # 定义缓存key
            proxy_cache_key $host$uri$is_args$args;
            # 针对返回装装他码单独定义缓存时间
            proxy_cache_valid 200 304 10m;
            # url 上代用 nocache 获取请求投中代用 nocache，切值为true 时不走缓存。
            proxy_cache_bypass $arg_nocache $http_nocahe;

            proxy_pass http://localhost:8080;
    }
}
```

#### 客户端缓存
- 浏览器端缓存
主要是利用 Cache-Control 参数。

- H5 缓存
html5缓存主要可以分为http协议缓存、应用缓存、DOM Storage、webSQL和indexedDB

#### Redis与Memcached比较

|                |                            Redis                             |                          Memcached                           |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 支持的数据结构 |                  哈希、列表、集合、有序集合                  |                         纯kev-value                          |
|   持久化支持   |                              有                              |                              无                              |
|   高可用支持   | redis天然支持集群功能，可以实现主动复制，读写分离。官方也提供了sentinel集群管理工具，能够实现主从服务监控，故障自动转移，这一切，对于客户端都是透明的，无需程序改动，也无需人工介入 |                         需要二次开发                         |
| 存储value容量  |                           最大512M                           |                            最大1M                            |
|    内存分配    |                  临时申请空间，可能导致碎片                  |       预分配内存池的方式管理内存，能够省去内存分配时间       |
|  虚拟内存使用  | 有自己的VM机制，理论上能够存储比物理内存更多的数据，当数据超量时，会引发swap，把冷数据刷到磁盘上 |                  所有的数据存储在物理内存里                  |
|    网络模型    | 非阻塞IO复用模型,提供一些非KV存储之外的排序，聚合功能，在执行这些功能时，复杂的CPU计算，会阻塞整个IO调度 |                       非阻塞IO复用模型                       |
| 水平扩展的支持 |                             暂无                             |                             暂无                             |
|     多线程     |                       Redis支持单线程                        |       Memcached支持多线程,CPU利用方面Memcache优于Redis       |
|    过期策略    |                   有专门线程，清除缓存数据                   | 懒淘汰机制：每次往缓存放入数据的时候，都会存一个时间，在读取的时候要和设置的时间做TTL比较来判断是否过期 |
|    单机QPS     |                            约10W                             |                            约60W                             |
|  源代码可读性  |                         代码清爽简洁                         |      能是考虑了太多的扩展性，多系统的兼容性，代码不清爽      |
|    适用场景    |    复杂数据结构、有持久化、高可用需求、value存储内容较大     |            纯KV，数据量非常大，并发量非常大的业务            |


- Memcached
采用多路复用技术提高并发性。
slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。
好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。

- Redis底层原理
使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。
使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。

#### 分层缓存架构设计

 ![分层缓存架构](https://user-gold-cdn.xitu.io/2018/7/9/1647c7f9ec13f9c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

 #### 缓存带来的复杂度问题

- 数据一致性

- 缓存穿透
	 解决方案：对结果为空的数据也进行缓存，当此key有数据后，清理缓存；一定不存在的key，采用布隆过滤器，建立一个大的Bitmap中，查询时通过该bitmap过滤

- 缓存雪崩

- 缓存高可用
	分布式：实现数据的海量缓存
	复制：实现缓存数据节点的高可用

- 缓存热点
	复制多份缓存副本，把请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力

#### 缓存失效策略
- FIFO：First In First Out，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。

- LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰。

- LFU：Least Frequently Used，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。